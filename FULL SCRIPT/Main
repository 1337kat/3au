--// =====================================================================================
--//   PAYLOAD0 ‚Ä¢ COMPLETE SYSTEM (BRIGHT GREEN GLOW + RESTORABLE REMOVER + ARC LINES)
--//   ‚Ä¢ Main: Smart Aim + One-Key Push (A or D only) + Bright Green Glow
--//   ‚Ä¢ Remover: Auto ACTIVE (Unions by size/Court+Lines + anything named "Net"), [P] toggle
--//   ‚Ä¢ Visuals: Smooth BLACK neon arc lines around each real Rim (no dots)
--//   ‚Ä¢ Main toggles: [V] System ON/OFF ‚Ä¢ [O] Visuals ON/OFF ‚Ä¢ [P] Remover Hide/Restore
--// =====================================================================================

-- === SERVICES ===
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local CoreGui = game:GetService("CoreGui")
local Workspace = game:GetService("Workspace")
local Camera = workspace.CurrentCamera

local plr = Players.LocalPlayer
local char = plr.Character or plr.CharacterAdded:Wait()
local remotes = ReplicatedStorage:WaitForChild("Remotes")
local shootRemote = remotes:WaitForChild("Shoot")

-- =====================================================================
-- =============== MAIN: BRIGHT GREEN GLOW + PUSH & SHOOT ===============
-- =====================================================================

getgenv().PAYLOAD0_SYSTEM_ACTIVE = true
local VisualsEnabled = true
local shootKey = nil
local selectedRim = nil
local activeNotifyGui = nil

-- Tunables
local PERFECT_DISTANCES = {54.97, 61.53, 68.10}
local CLAMP_RADIUS = 1
local ACTIVE_RANGE_MAIN = 90
local MAX_PUSH = 0.06
local DAMPING = 0.9

-- Colors
local COLOR_GREEN       = Color3.fromRGB(0, 255, 100)
local COLOR_GREEN_SOFT  = Color3.fromRGB(0, 200, 80)
local COLOR_RED         = Color3.fromRGB(255, 60, 60)
local COLOR_YELLOW      = Color3.fromRGB(255, 180, 80)
local COLOR_WHITE       = Color3.fromRGB(255, 255, 255)

-- === NOTIFY (small, fast pop) ===
local function notify(msg, color)
	if not VisualsEnabled then return end
	if activeNotifyGui and activeNotifyGui.Parent then
		activeNotifyGui:Destroy()
	end
	local gui = Instance.new("ScreenGui")
	gui.ResetOnSpawn = false
	gui.Parent = CoreGui
	activeNotifyGui = gui

	local label = Instance.new("TextLabel")
	label.Parent = gui
	label.AnchorPoint = Vector2.new(0.5, 0.5)
	label.Position = UDim2.new(0.5, 0, 0.9, 0)
	label.BackgroundTransparency = 1
	label.TextColor3 = color or COLOR_WHITE
	label.Font = Enum.Font.Code
	label.TextSize = 26
	label.Text = msg

	task.spawn(function()
		task.wait(1.2)
		if gui == activeNotifyGui then
			gui:Destroy()
			activeNotifyGui = nil
		end
	end)
end

-- === RIM TRACKING by size (real rim discrimination) ===
local RimSize = Vector3.new(3.632131576538086, 0.5587897300720215, 3.632131576538086)
local Rims = {}

local function addRim(rim)
	table.insert(Rims, rim)
end

local function removeRim(rim)
	for i, r in ipairs(Rims) do
		if r == rim then
			table.remove(Rims, i)
			break
		end
	end
	if selectedRim == rim then
		selectedRim = nil
	end
end

Workspace.DescendantAdded:Connect(function(o)
	if o:IsA("BasePart") and o.Name == "Rim" and o.Size == RimSize then
		addRim(o)
	end
end)
for _, v in ipairs(Workspace:GetDescendants()) do
	if v:IsA("BasePart") and v.Name == "Rim" and v.Size == RimSize then
		addRim(v)
	end
end
Workspace.DescendantRemoving:Connect(function(o)
	if o:IsA("BasePart") then
		removeRim(o)
	end
end)

-- === AUTO LOCK NEAREST, ON-SCREEN RIM ===
task.spawn(function()
	while task.wait(0.1) do
		if not getgenv().PAYLOAD0_SYSTEM_ACTIVE then continue end
		local root = plr.Character and plr.Character:FindFirstChild("HumanoidRootPart")
		if not root then continue end

		local best, bestDist = nil, 85
		for _, rim in ipairs(Rims) do
			if rim:IsDescendantOf(Workspace) then
				local dist = (rim.Position - root.Position).Magnitude
				if dist < bestDist then
					local _, on = Camera:WorldToViewportPoint(rim.Position)
					if on then
						best, bestDist = rim, dist
					end
				end
			end
		end
		if best and best ~= selectedRim then
			selectedRim = best
			notify("üéØ Auto-Locked Nearest Rim", COLOR_GREEN)
		end
	end
end)

-- === TOGGLES: [O] visuals, [V] system ===
UserInputService.InputBegan:Connect(function(input, gp)
	if gp then return end

	-- [O] Visuals
	if input.KeyCode == Enum.KeyCode.O then
		VisualsEnabled = not VisualsEnabled
		notify(VisualsEnabled and "üëÅ Visuals ON" or "üôà Visuals OFF", VisualsEnabled and COLOR_GREEN or COLOR_RED)
	end

	-- [V] System (clean standalone toggle behavior)
	if input.KeyCode == Enum.KeyCode.V then
		getgenv().PAYLOAD0_SYSTEM_ACTIVE = not getgenv().PAYLOAD0_SYSTEM_ACTIVE
		notify(getgenv().PAYLOAD0_SYSTEM_ACTIVE and "‚úÖ System ON" or "üö´ System OFF",
			getgenv().PAYLOAD0_SYSTEM_ACTIVE and COLOR_GREEN or COLOR_RED)
	end
end)

-- === CAPTURE SHOOT KEY ===
local old
old = hookmetamethod(game, "__namecall", function(self, ...)
	local m = getnamecallmethod()
	if m == "FireServer" and self == shootRemote then
		local args = {...}
		if type(args[3]) == "string" and not shootKey then
			shootKey = args[3]
			notify("Shoot key captured!", COLOR_GREEN)
		end
	end
	return old(self, ...)
end)

-- === AIM/SHOOT ===
local lastTick, moveOffset = 0, Vector3.zero
local function computeOffset()
	if tick() - lastTick > 0.1 then
		local hum = plr.Character and plr.Character:FindFirstChildOfClass("Humanoid")
		local md = (hum and hum.MoveDirection) or Vector3.zero
		moveOffset = Vector3.new(md.X * 1.5, 0, md.Z * 1.5)
		lastTick = tick()
	end
	return moveOffset
end

local function computeArc(distance)
	return Vector3.new(0, 43 + (distance / 15), 0)
end

local function smartAim(rim)
	local offset = computeOffset()
	local root = plr.Character and plr.Character:FindFirstChild("HumanoidRootPart")
	if not root then return rim.Position end
	local dist = (root.Position - rim.Position).Magnitude
	return rim.Position + computeArc(dist) - offset
end

local function shootAtTarget()
	if not getgenv().PAYLOAD0_SYSTEM_ACTIVE then return end
	if not (selectedRim and selectedRim:IsDescendantOf(Workspace)) then
		return notify("‚ùå No Target", COLOR_RED)
	end
	if not shootKey then
		return notify("‚öôÔ∏è Shoot Key Missing", COLOR_YELLOW)
	end

	local c = plr.Character
	if not c then return end
	local head, root = c:FindFirstChild("Head"), c.PrimaryPart
	if not (head and root) then return end

	local aimPos = smartAim(selectedRim)
	local dir = (aimPos - head.Position).Unit
	local shootFrom = root.Position + dir * 3.8
	if shootFrom.Y - root.Position.Y < 4 then
		shootFrom = root.Position + dir * 4
	end

	shootRemote:FireServer(aimPos, shootFrom, shootKey)
	notify("üèÄ Shot Fired!", COLOR_GREEN)
end

UserInputService.InputBegan:Connect(function(i, gp)
	if gp or not getgenv().PAYLOAD0_SYSTEM_ACTIVE then return end
	if i.UserInputType == Enum.UserInputType.MouseButton1 then
		shootAtTarget()
	end
end)

-- === BRIGHT GREEN GLOW + ONE-KEY (A/D) PUSH RULE ===
local hl = CoreGui:FindFirstChild("PerfectRangeGlow") or Instance.new("Highlight")
hl.Name = "PerfectRangeGlow"
hl.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
hl.FillTransparency = 0.25
hl.OutlineTransparency = 0
hl.Adornee = plr.Character
hl.Parent = CoreGui
hl.Enabled = true

local moveKeys = { W=false, A=false, S=false, D=false }
UserInputService.InputBegan:Connect(function(i, gp)
	if gp then return end
	if moveKeys[i.KeyCode.Name] ~= nil then moveKeys[i.KeyCode.Name] = true end
end)
UserInputService.InputEnded:Connect(function(i, gp)
	if gp then return end
	if moveKeys[i.KeyCode.Name] ~= nil then moveKeys[i.KeyCode.Name] = false end
end)

local function shouldPush()
	local count = 0
	for _, v in pairs(moveKeys) do if v then count += 1 end end
	return count == 1 and (moveKeys.A or moveKeys.D)
end

-- Push uses small helper parts named "Lol" under Rim models (as per your setup)
local rimsForPush = {}
for _, v in ipairs(Workspace:GetDescendants()) do
	if v:IsA("BasePart") and v.Name == "Lol" and v.Parent and v.Parent.Name == "Rim" then
		table.insert(rimsForPush, v)
	end
end

local function nearestRimForPush(rootPos)
	local nearest, nearestDist
	for _, rim in ipairs(rimsForPush) do
		if rim:IsDescendantOf(Workspace) then
			local rimXZ = Vector3.new(rim.Position.X, 0, rim.Position.Z)
			local dist = (rimXZ - Vector3.new(rootPos.X, 0, rootPos.Z)).Magnitude
			if not nearestDist or dist < nearestDist then
				nearest, nearestDist = rim, dist
			end
		end
	end
	return nearest, nearestDist
end

local function nearestPerfectDistance(current)
	local n, best
	for _, pd in ipairs(PERFECT_DISTANCES) do
		local diff = math.abs(pd - current)
		if (not best) or diff < best then
			n, best = pd, diff
		end
	end
	return n
end

local smoothBias = Vector3.zero
RunService.RenderStepped:Connect(function()
	if not getgenv().PAYLOAD0_SYSTEM_ACTIVE then
		hl.Enabled = false
		return
	else
		hl.Enabled = VisualsEnabled
	end

	local c = plr.Character
	local hum = c and c:FindFirstChildOfClass("Humanoid")
	local root = c and c:FindFirstChild("HumanoidRootPart")
	if not (hum and root) then return end

	local rim, dist = nearestRimForPush(root.Position)
	if not rim or dist > ACTIVE_RANGE_MAIN then
		hl.Enabled = false
		smoothBias = Vector3.zero
		return
	end

	local target = nearestPerfectDistance(dist)
	local diff = dist - target
	local absDiff = math.abs(diff)
	local desired = Vector3.zero

	-- One-way outward push only; and only if exactly ONE of A/D is down
	if shouldPush() and absDiff < CLAMP_RADIUS then
		local strength = (CLAMP_RADIUS - absDiff) / CLAMP_RADIUS
		local toRim = Vector3.new(rim.Position.X, 0, rim.Position.Z) - Vector3.new(root.Position.X, 0, root.Position.Z)
		local distSign = math.sign(diff)
		if distSign > 0 then -- only push outward if you're inside the ring
			local pushDir = -toRim.Unit
			desired = pushDir * math.min(strength * MAX_PUSH, MAX_PUSH)
		end
	end

	smoothBias = smoothBias * DAMPING + desired * (1 - DAMPING)
	root.CFrame += Vector3.new(smoothBias.X, 0, smoothBias.Z)

	-- Glow feedback
	if not VisualsEnabled then return end
	if absDiff <= 0.10 then
		hl.FillColor, hl.OutlineColor = COLOR_GREEN, COLOR_GREEN
	elseif absDiff < CLAMP_RADIUS then
		hl.FillColor, hl.OutlineColor = COLOR_GREEN_SOFT, COLOR_GREEN_SOFT
	else
		hl.Enabled = false
	end
end)

plr.CharacterAdded:Connect(function(cnew)
	task.wait(0.5)
	hl.Adornee = cnew
end)

-- =====================================================================
-- =============== MODULE: MASTER RESTORABLE REMOVER ====================
-- =====================================================================

local TOGGLE_KEY_REMOVER = Enum.KeyCode.P
local TARGET_SIZES = {
	Vector3.new(14.074419021606445, 0.1991105079650879, 68.00189208984375),
	Vector3.new(20.78681182861328, 0.10193014144897461, 67.00210571289062),
}
local SIZE_TOLERANCE = 0.0005
local removalEnabled = true -- AUTO ACTIVE
local removedObjects = {}

local function sizeMatchesAny(size)
	for _, t in ipairs(TARGET_SIZES) do
		if math.abs(size.X - t.X) <= SIZE_TOLERANCE
		and math.abs(size.Y - t.Y) <= SIZE_TOLERANCE
		and math.abs(size.Z - t.Z) <= SIZE_TOLERANCE then
			return true
		end
	end
	return false
end

local function isInsideCourtAndLines(obj)
	local hasCourt, hasLines = false, false
	local cur = obj
	while cur do
		local n = cur.Name:lower()
		if n:find("court") then hasCourt = true end
		if n:find("lines") then hasLines = true end
		cur = cur.Parent
	end
	return hasCourt and hasLines
end

local function shouldRemove(obj)
	if obj:IsA("UnionOperation") and (sizeMatchesAny(obj.Size) or isInsideCourtAndLines(obj)) then
		return true
	end
	if (obj:IsA("BasePart") or obj:IsA("Model") or obj:IsA("Folder")) and obj.Name:lower() == "net" then
		return true
	end
	return false
end

local function cloneData(obj)
	local c = obj:Clone()
	c.Parent = nil
	return {instance = c, parent = obj.Parent}
end

local function removeMatchingObjects(container)
	for _, d in ipairs(container:GetDescendants()) do
		if shouldRemove(d) then
			table.insert(removedObjects, cloneData(d))
			d:Destroy()
		end
	end
end

local function restoreObjects()
	for _, data in ipairs(removedObjects) do
		if data.instance and data.parent then
			data.instance.Parent = data.parent
		end
	end
	removedObjects = {}
end

local function toggleRemoval()
	removalEnabled = not removalEnabled
	if removalEnabled then
		print("[Payload0] REMOVER ACTIVE ‚Äî hiding Unions + Nets")
		removeMatchingObjects(Workspace)
	else
		print("[Payload0] RESTORING ‚Äî bringing back Unions + Nets")
		restoreObjects()
	end
end

UserInputService.InputBegan:Connect(function(i, gp)
	if gp then return end
	if i.KeyCode == TOGGLE_KEY_REMOVER then
		toggleRemoval()
	end
end)

Workspace.DescendantAdded:Connect(function(o)
	if removalEnabled and shouldRemove(o) then
		task.wait(0.05)
		if o and o.Parent then
			table.insert(removedObjects, cloneData(o))
			o:Destroy()
		end
	end
end)

task.defer(function()
	removeMatchingObjects(Workspace)
end)

-- =====================================================================
-- =============== MODULE: RIM ARC LINES (NO DOTS) ======================
-- =====================================================================

-- Visual config
local ARC_RING_ARC_DEGREES = 180           -- base arc
local ARC_DEGREE_STEP = 2                  -- smaller => smoother
local ARC_DOT_MATERIAL = Enum.Material.Neon
local ARC_DOT_COLOR = Color3.fromRGB(0, 0, 0) -- pure black neon
local ARC_LINK_THICKNESS = 0.25
local ARC_ACTIVE_RANGE = 100
local ARC_RIM_SIZE = RimSize
local ARC_HEIGHT_OFFSET = -18.259          -- shoe-height-ish

-- Per-line extension in degrees (pos = extend; neg = shorten)
local ARC_ADJUSTMENTS = {
	[1] = 12,     -- 54.97 line extended a bit
	[2] = -9,     -- 61.53 shortened a bit
	[3] = -27,    -- 68.10 shortened more
}

local RimLinesReg = {}
local RimArcModels = {}

local function createArcLines(rimPart, radius, extraDegrees)
	local model = Instance.new("Model")
	model.Name = "Payload0_ArcLine"
	model.Parent = Workspace

	local forward = rimPart.CFrame.LookVector
	local right = rimPart.CFrame.RightVector
	local points = {}

	local startDeg = -ARC_RING_ARC_DEGREES/2 - extraDegrees
	local endDeg   =  ARC_RING_ARC_DEGREES/2 + extraDegrees

	for deg = startDeg, endDeg, ARC_DEGREE_STEP do
		local rad = math.rad(deg)
		local offset = (forward * math.cos(rad) + right * math.sin(rad)) * radius
		table.insert(points, rimPart.Position + Vector3.new(offset.X, ARC_HEIGHT_OFFSET, offset.Z))
	end

	for i = 1, #points - 1 do
		local a, b = points[i], points[i+1]
		local dist = (a - b).Magnitude
		local link = Instance.new("Part")
		link.Name = "ArcLink"
		link.Anchored = true
		link.CanCollide = false
		link.Material = ARC_DOT_MATERIAL
		link.Color = ARC_DOT_COLOR
		link.Transparency = 0
		link.Size = Vector3.new(ARC_LINK_THICKNESS, ARC_LINK_THICKNESS, dist)
		link.CFrame = CFrame.new(a, b) * CFrame.new(0, 0, -dist/2)
		link.Parent = model
	end

	return model
end

local function registerRimForArcs(rim)
	if RimLinesReg[rim] then return end
	RimLinesReg[rim] = true

	local rimModel = Instance.new("Model")
	rimModel.Name = "Payload0_RimArcs_" .. rim:GetDebugId()
	rimModel.Parent = Workspace

	for i, dist in ipairs(PERFECT_DISTANCES) do
		local extra = ARC_ADJUSTMENTS[i] or 0
		local m = createArcLines(rim, dist, extra)
		m.Parent = rimModel
	end

	RimArcModels[rim] = rimModel
end

local function unregisterRimForArcs(rim)
	if RimArcModels[rim] then
		RimArcModels[rim]:Destroy()
	end
	RimLinesReg[rim] = nil
	RimArcModels[rim] = nil
end

Workspace.DescendantAdded:Connect(function(o)
	if o:IsA("BasePart") and o.Name == "Rim" and o.Size == ARC_RIM_SIZE then
		registerRimForArcs(o)
	end
end)
Workspace.DescendantRemoving:Connect(function(o)
	if RimLinesReg[o] then
		unregisterRimForArcs(o)
	end
end)

for _, v in ipairs(Workspace:GetDescendants()) do
	if v:IsA("BasePart") and v.Name == "Rim" and v.Size == ARC_RIM_SIZE then
		registerRimForArcs(v)
	end
end

-- Arc visibility vs distance
local hrp = char:WaitForChild("HumanoidRootPart")
RunService.RenderStepped:Connect(function()
	for rim, model in pairs(RimArcModels) do
		if rim:IsDescendantOf(Workspace) and model.Parent then
			local dist = (rim.Position - hrp.Position).Magnitude
			local active = dist <= ARC_ACTIVE_RANGE
			for _, part in ipairs(model:GetDescendants()) do
				if part:IsA("BasePart") then
					part.Transparency = active and 0 or 1
				end
			end
		end
	end
end)

-- =====================================================================
print("[üèÄ PAYLOAD0 ‚Äî Unified System Loaded]")
print("‚Ä¢ [V] Toggle main system    ‚Ä¢ [O] Toggle visuals    ‚Ä¢ [P] Toggle Remover (hide/restore)")
print("‚Ä¢ Bright Green Glow active  ‚Ä¢ Restorable Remover is AUTO-ACTIVE")
