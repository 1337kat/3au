--// =====================================================================================
--//   PAYLOAD0 ‚Ä¢ COMPLETE SYSTEM (BRIGHT GREEN GLOW + RESTORABLE REMOVER + ARC LINES)
--//   ‚Ä¢ Main: Smart Aim + One-Key Push (A or D only) + Bright Green Glow
--//   ‚Ä¢ Remover: Auto ACTIVE (Unions by size/Court+Lines + anything named "Net"), [P] toggle
--//   ‚Ä¢ Visuals: Smooth BLACK neon arc lines around each real Rim (no dots)
--//   ‚Ä¢ Main toggles: [V] System ON/OFF ‚Ä¢ [O] Visuals ON/OFF ‚Ä¢ [P] Remover Hide/Restore
--// =====================================================================================

-- === SERVICES ===
local Players = game:GetService('Players')
local UserInputService = game:GetService('UserInputService')
local RunService = game:GetService('RunService')
local ReplicatedStorage = game:GetService('ReplicatedStorage')
local CoreGui = game:GetService('CoreGui')
local Workspace = game:GetService('Workspace')
local Camera = workspace.CurrentCamera

local plr = Players.LocalPlayer
local char = plr.Character or plr.CharacterAdded:Wait()
local remotes = ReplicatedStorage:WaitForChild('Remotes')
local shootRemote = remotes:WaitForChild('Shoot')

-- =====================================================================
-- =============== MAIN: BRIGHT GREEN GLOW LOGIC ========================
-- =====================================================================

-- === STATE ===
getgenv().PAYLOAD0_SYSTEM_ACTIVE = true
local VisualsEnabled = true
local shootKey: string? = nil
local selectedRim: BasePart? = nil

-- === MAIN CONFIGURATION ===
local PERFECT_DISTANCES = { 54.97, 61.53, 68.10 }
local CLAMP_RADIUS = 1
local ACTIVE_RANGE_MAIN = 90
local MAX_PUSH = 0.06
local DAMPING = 0.9

-- Bright green glow colors
local COLOR_GREEN = Color3.fromRGB(0, 255, 100)
local COLOR_GREEN_SOFT = Color3.fromRGB(0, 200, 80)

-- === INSTANT NOTIFY ===
local function notify(msg, color)
    if not VisualsEnabled then
        return
    end
    local gui = Instance.new('ScreenGui')
    gui.IgnoreGuiInset = true
    gui.ResetOnSpawn = false
    gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    gui.Parent = CoreGui

    local label = Instance.new('TextLabel')
    label.Parent = gui
    label.AnchorPoint = Vector2.new(0.5, 0.5)
    label.BackgroundTransparency = 1
    label.TextColor3 = color or Color3.new(1, 1, 1)
    label.Font = Enum.Font.Code
    label.TextSize = 24
    label.Text = msg
    label.Position = UDim2.new(0.5, 0, 0.9, 0)
    label.TextTransparency = 0

    task.spawn(function()
        for i = 0, 1, 0.1 do
            label.TextTransparency = i
            task.wait(0.04)
        end
        gui:Destroy()
    end)
end

-- === RIM TRACKING (for auto-lock by size) ===
local RimSize =
    Vector3.new(3.632131576538086, 0.5587897300720215, 3.632131576538086)
local Rims: { BasePart } = {}

Workspace.DescendantAdded:Connect(function(o)
    if o:IsA('BasePart') and o.Name == 'Rim' and o.Size == RimSize then
        table.insert(Rims, o)
    end
end)
for _, v in ipairs(Workspace:GetDescendants()) do
    if v:IsA('BasePart') and v.Name == 'Rim' and v.Size == RimSize then
        table.insert(Rims, v)
    end
end
Workspace.DescendantRemoving:Connect(function(o)
    for i, rim in ipairs(Rims) do
        if rim == o then
            table.remove(Rims, i)
            break
        end
    end
    if selectedRim == o then
        selectedRim = nil
    end
end)

-- === AUTO RIM LOCK (screen-visible, nearest) ===
task.spawn(function()
    while task.wait(0.1) do
        if not getgenv().PAYLOAD0_SYSTEM_ACTIVE then
            continue
        end
        local root = plr.Character
            and plr.Character:FindFirstChild('HumanoidRootPart')
        if not root then
            continue
        end
        local bestRim, bestDist = nil, 85
        for _, rim in ipairs(Rims) do
            if rim:IsDescendantOf(Workspace) then
                local dist = (rim.Position - root.Position).Magnitude
                if dist < bestDist then
                    local _, on = Camera:WorldToViewportPoint(rim.Position)
                    if on then
                        bestRim, bestDist = rim, dist
                    end
                end
            end
        end
        if bestRim and bestRim ~= selectedRim then
            selectedRim = bestRim
            notify('üéØ Auto-Locked Nearest Rim', COLOR_GREEN)
        end
    end
end)

-- === TOGGLES (Main visual + system) ===
UserInputService.InputBegan:Connect(function(i, gp)
    if gp then
        return
    end
    if i.KeyCode == Enum.KeyCode.O then
        VisualsEnabled = not VisualsEnabled
    elseif i.KeyCode == Enum.KeyCode.V then
        getgenv().PAYLOAD0_SYSTEM_ACTIVE = not getgenv().PAYLOAD0_SYSTEM_ACTIVE
        if VisualsEnabled then
            notify(
                getgenv().PAYLOAD0_SYSTEM_ACTIVE and '‚úÖ System ON'
                    or '‚ùå System OFF',
                getgenv().PAYLOAD0_SYSTEM_ACTIVE and COLOR_GREEN
                    or Color3.new(1, 0, 0)
            )
        end
    end
end)

-- === CAPTURE SHOOT KEY ===
local old
old = hookmetamethod(game, '__namecall', function(self, ...)
    local m = getnamecallmethod()
    if m == 'FireServer' and self == shootRemote then
        local args = { ... }
        if type(args[3]) == 'string' and not shootKey then
            shootKey = args[3]
            notify('Shoot key captured!', COLOR_GREEN)
        end
    end
    return old(self, ...)
end)

-- === SHOOT LOGIC ===
local lastTick, moveOffset = 0, Vector3.zero
local function computeOffset()
    if tick() - lastTick > 0.1 then
        local hum = plr.Character
            and plr.Character:FindFirstChildOfClass('Humanoid')
        local moveDir = (hum and hum.MoveDirection) or Vector3.zero
        moveOffset = Vector3.new(moveDir.X * 1.5, 0, moveDir.Z * 1.5)
        lastTick = tick()
    end
    return moveOffset
end

local function computeArc(dist)
    return Vector3.new(0, 43 + (dist / 15), 0)
end

local function smartAim(rim)
    local offset = computeOffset()
    local root = plr.Character
        and plr.Character:FindFirstChild('HumanoidRootPart')
    if not root then
        return rim.Position
    end
    local dist = (root.Position - rim.Position).Magnitude
    return rim.Position + computeArc(dist) - offset
end

local function shootAtTarget()
    if not getgenv().PAYLOAD0_SYSTEM_ACTIVE then
        return
    end
    if not (selectedRim and selectedRim:IsDescendantOf(Workspace)) then
        return notify('‚ùå No Target', Color3.new(1, 0.3, 0.3))
    end
    if not shootKey then
        return notify('‚öôÔ∏è Shoot Key Missing', Color3.new(1, 0.8, 0.3))
    end

    local char = plr.Character
    if not char then
        return
    end
    local head, root = char:FindFirstChild('Head'), char.PrimaryPart
    if not (head and root) then
        return
    end

    local aimPos = smartAim(selectedRim)
    local dir = (aimPos - head.Position).Unit
    local shootFrom = root.Position + dir * 3.8
    if shootFrom.Y - root.Position.Y < 4 then
        shootFrom = root.Position + dir * 4
    end
    shootRemote:FireServer(aimPos, shootFrom, shootKey)
    notify('üèÄ Shot Fired!', COLOR_GREEN)
end

UserInputService.InputBegan:Connect(function(i, gp)
    if gp or not getgenv().PAYLOAD0_SYSTEM_ACTIVE then
        return
    end
    if i.UserInputType == Enum.UserInputType.MouseButton1 then
        shootAtTarget()
    end
end)

-- === ALIGN ASSIST (Bright Green Glow highlight) ===
local hl = CoreGui:FindFirstChild('PerfectRangeGlow')
    or Instance.new('Highlight')
hl.Name = 'PerfectRangeGlow'
hl.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
hl.FillTransparency = 0.25
hl.OutlineTransparency = 0
hl.Adornee = plr.Character
hl.Parent = CoreGui
hl.Enabled = true

local moveKeys = { W = false, A = false, S = false, D = false }
UserInputService.InputBegan:Connect(function(i, gp)
    if gp then
        return
    end
    if moveKeys[i.KeyCode.Name] ~= nil then
        moveKeys[i.KeyCode.Name] = true
    end
end)
UserInputService.InputEnded:Connect(function(i, gp)
    if gp then
        return
    end
    if moveKeys[i.KeyCode.Name] ~= nil then
        moveKeys[i.KeyCode.Name] = false
    end
end)

local function shouldPush()
    local count = 0
    for _, v in pairs(moveKeys) do
        if v then
            count += 1
        end
    end
    return count == 1 and (moveKeys.A or moveKeys.D)
end

-- Rim finder for push logic (kept as in your main)
local rimsForPush = {}
for _, v in ipairs(Workspace:GetDescendants()) do
    if
        v:IsA('BasePart')
        and v.Name == 'Lol'
        and v.Parent
        and v.Parent.Name == 'Rim'
    then
        table.insert(rimsForPush, v)
    end
end

local function nearestRim(rootPos)
    local nearest, nearestDist
    for _, rim in ipairs(rimsForPush) do
        if rim:IsDescendantOf(Workspace) then
            local rimXZ = Vector3.new(rim.Position.X, 0, rim.Position.Z)
            local dist = (rimXZ - Vector3.new(rootPos.X, 0, rootPos.Z)).Magnitude
            if not nearestDist or dist < nearestDist then
                nearest, nearestDist = rim, dist
            end
        end
    end
    return nearest, nearestDist
end

local function getNearestPerfectDistance(current)
    local nearest, smallestDiff
    for _, pd in ipairs(PERFECT_DISTANCES) do
        local diff = math.abs(pd - current)
        if not smallestDiff or diff < smallestDiff then
            nearest, smallestDiff = pd, diff
        end
    end
    return nearest
end

local smoothBias = Vector3.zero
RunService.RenderStepped:Connect(function()
    if not getgenv().PAYLOAD0_SYSTEM_ACTIVE then
        hl.Enabled = false
        return
    else
        hl.Enabled = VisualsEnabled
    end

    local char = plr.Character
    local hum = char and char:FindFirstChildOfClass('Humanoid')
    local root = char and char:FindFirstChild('HumanoidRootPart')
    if not (hum and root) then
        return
    end

    local rim, dist = nearestRim(root.Position)
    if not rim or dist > ACTIVE_RANGE_MAIN then
        hl.Enabled = false
        smoothBias = Vector3.zero
        return
    end

    local target = getNearestPerfectDistance(dist)
    local diff = dist - target
    local absDiff = math.abs(diff)
    local desired = Vector3.zero

    if shouldPush() and absDiff < CLAMP_RADIUS then
        local strength = (CLAMP_RADIUS - absDiff) / CLAMP_RADIUS
        local toRim = Vector3.new(rim.Position.X, 0, rim.Position.Z)
            - Vector3.new(root.Position.X, 0, root.Position.Z)
        local distSign = math.sign(diff)
        if distSign > 0 then
            local pushDir = -toRim.Unit
            desired = pushDir * math.min(strength * MAX_PUSH, MAX_PUSH)
        end
    end

    smoothBias = smoothBias * DAMPING + desired * (1 - DAMPING)
    root.CFrame += Vector3.new(smoothBias.X, 0, smoothBias.Z)

    if not VisualsEnabled then
        return
    end
    if absDiff <= 0.10 then
        hl.FillColor, hl.OutlineColor = COLOR_GREEN, COLOR_GREEN
    elseif absDiff < CLAMP_RADIUS then
        hl.FillColor, hl.OutlineColor = COLOR_GREEN_SOFT, COLOR_GREEN_SOFT
    else
        hl.Enabled = false
        return
    end
end)

plr.CharacterAdded:Connect(function(c)
    task.wait(0.5)
    hl.Adornee = c
end)

-- =====================================================================
-- =============== MODULE: MASTER RESTORABLE REMOVER ====================
-- =====================================================================

-- CONFIG
local TOGGLE_KEY_REMOVER = Enum.KeyCode.P -- <<<< per your choice B
local TARGET_SIZES = {
    Vector3.new(14.074419021606445, 0.1991105079650879, 68.00189208984375),
    Vector3.new(20.78681182861328, 0.10193014144897461, 67.00210571289062),
}
local SIZE_TOLERANCE = 0.0005

-- STATE
local removalEnabled = true -- Auto ACTIVE
local removedObjects = {}

-- HELPERS
local function sizeMatchesAny(size: Vector3)
    for _, target in ipairs(TARGET_SIZES) do
        if
            math.abs(size.X - target.X) <= SIZE_TOLERANCE
            and math.abs(size.Y - target.Y) <= SIZE_TOLERANCE
            and math.abs(size.Z - target.Z) <= SIZE_TOLERANCE
        then
            return true
        end
    end
    return false
end

local function isInsideCourtAndLines(obj)
    local hasCourt, hasLines = false, false
    local current = obj
    while current do
        local name = current.Name:lower()
        if string.find(name, 'court') then
            hasCourt = true
        elseif string.find(name, 'lines') then
            hasLines = true
        end
        current = current.Parent
    end
    return hasCourt and hasLines
end

local function shouldRemove(obj)
    if
        obj:IsA('UnionOperation')
        and (sizeMatchesAny(obj.Size) or isInsideCourtAndLines(obj))
    then
        return true
    end
    if
        (obj:IsA('BasePart') or obj:IsA('Model') or obj:IsA('Folder'))
        and obj.Name:lower() == 'net'
    then
        return true
    end
    return false
end

local function cloneData(obj)
    local clone = obj:Clone()
    clone.Parent = nil
    return { instance = clone, parent = obj.Parent }
end

local function removeMatchingObjects(container)
    for _, descendant in ipairs(container:GetDescendants()) do
        if shouldRemove(descendant) then
            table.insert(removedObjects, cloneData(descendant))
            print('[Payload0] Removed:', descendant:GetFullName())
            descendant:Destroy()
        end
    end
end

local function restoreObjects()
    for _, data in ipairs(removedObjects) do
        if data.instance and data.parent then
            data.instance.Parent = data.parent
        end
    end
    print('[Payload0] Restored', #removedObjects, 'objects (Unions + Nets).')
    removedObjects = {}
end

local function toggleRemoval()
    removalEnabled = not removalEnabled
    if removalEnabled then
        print(
            '[Payload0] REMOVER: ACTIVE ‚Äî All matching Unions + Nets removed (Press P to restore)'
        )
        removeMatchingObjects(Workspace)
    else
        print(
            '[Payload0] REMOVER: RESTORING ‚Äî All Unions + Nets restored (Press P to re-hide)'
        )
        restoreObjects()
    end
end

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then
        return
    end
    if input.KeyCode == TOGGLE_KEY_REMOVER then
        toggleRemoval()
    end
end)

Workspace.DescendantAdded:Connect(function(obj)
    if removalEnabled and shouldRemove(obj) then
        task.wait(0.05)
        if obj and obj.Parent then
            table.insert(removedObjects, cloneData(obj))
            print('[Payload0] Auto-Removed new:', obj:GetFullName())
            obj:Destroy()
        end
    end
end)

task.defer(function()
    print('[Payload0] AUTO REMOVER ACTIVE ‚Äî Cleaning Workspace...')
    removeMatchingObjects(Workspace)
end)

-- =====================================================================
-- =============== MODULE: RIM ARC LINES (NO DOTS) ======================
-- =====================================================================

-- VISUAL CONFIG (kept distinct to avoid name clashes)
local ARC_RING_ARC_DEGREES = 180
local ARC_DEGREE_STEP = 2 -- smaller = smoother curve
local ARC_DOT_MATERIAL = Enum.Material.Neon
local ARC_DOT_COLOR = Color3.fromRGB(0, 0, 0) -- black
local ARC_LINK_THICKNESS = 0.25
local ARC_ACTIVE_RANGE = 100
local ARC_RIM_SIZE = RimSize -- same size as main rim detection
local ARC_HEIGHT_OFFSET = -18.259 -- your shoe-height-ish offset

-- Per-line degree extension (positive = extend, negative = subtract)
local ARC_ADJUSTMENTS = {
    [1] = 12,
    [2] = -9,
    [3] = -27,
}

local RimLinesReg = {}
local RimArcModels = {}

local function createArcLines(
    rimPart: BasePart,
    radius: number,
    extraDegrees: number
)
    local model = Instance.new('Model')
    model.Name = 'Payload0_ArcLine'
    model.Parent = Workspace

    local forward = rimPart.CFrame.LookVector
    local right = rimPart.CFrame.RightVector
    local points = {}

    local startDeg = -ARC_RING_ARC_DEGREES / 2 - extraDegrees
    local endDeg = ARC_RING_ARC_DEGREES / 2 + extraDegrees

    for deg = startDeg, endDeg, ARC_DEGREE_STEP do
        local rad = math.rad(deg)
        local offset = (forward * math.cos(rad) + right * math.sin(rad))
            * radius
        table.insert(
            points,
            rimPart.Position
                + Vector3.new(offset.X, ARC_HEIGHT_OFFSET, offset.Z)
        )
    end

    for i = 1, #points - 1 do
        local a, b = points[i], points[i + 1]
        local dist = (a - b).Magnitude
        local link = Instance.new('Part')
        link.Name = 'ArcLink'
        link.Anchored = true
        link.CanCollide = false
        link.Material = ARC_DOT_MATERIAL
        link.Color = ARC_DOT_COLOR
        link.Transparency = 0
        link.Size = Vector3.new(ARC_LINK_THICKNESS, ARC_LINK_THICKNESS, dist)
        link.CFrame = CFrame.new(a, b) * CFrame.new(0, 0, -dist / 2)
        link.Parent = model
    end

    return model
end

local function registerRimForArcs(rim: BasePart)
    if RimLinesReg[rim] then
        return
    end
    RimLinesReg[rim] = true

    local rimModel = Instance.new('Model')
    rimModel.Name = 'Payload0_RimArcs_' .. rim:GetDebugId()
    rimModel.Parent = Workspace

    for i, dist in ipairs(PERFECT_DISTANCES) do
        local extra = ARC_ADJUSTMENTS[i] or 0
        local model = createArcLines(rim, dist, extra)
        model.Parent = rimModel
    end

    RimArcModels[rim] = rimModel
end

local function unregisterRimForArcs(rim: BasePart)
    if RimArcModels[rim] then
        RimArcModels[rim]:Destroy()
    end
    RimLinesReg[rim] = nil
    RimArcModels[rim] = nil
end

Workspace.DescendantAdded:Connect(function(o)
    if o:IsA('BasePart') and o.Name == 'Rim' and o.Size == ARC_RIM_SIZE then
        registerRimForArcs(o)
    end
end)
Workspace.DescendantRemoving:Connect(function(o)
    if RimLinesReg[o] then
        unregisterRimForArcs(o)
    end
end)
for _, v in ipairs(Workspace:GetDescendants()) do
    if v:IsA('BasePart') and v.Name == 'Rim' and v.Size == ARC_RIM_SIZE then
        registerRimForArcs(v)
    end
end

-- Range-based visibility for arc models
local hrp = char:WaitForChild('HumanoidRootPart')
RunService.RenderStepped:Connect(function()
    for rim, model in pairs(RimArcModels) do
        if rim:IsDescendantOf(Workspace) and model.Parent then
            local dist = (rim.Position - hrp.Position).Magnitude
            local active = dist <= ARC_ACTIVE_RANGE
            for _, part in ipairs(model:GetDescendants()) do
                if part:IsA('BasePart') then
                    part.Transparency = active and 0 or 1
                end
            end
        end
    end
end)

-- =====================================================================
print('[üèÄ PAYLOAD0 ‚Äî Unified System Loaded]')
print(
    '‚Ä¢ [V] Toggle main system    ‚Ä¢ [O] Toggle visuals    ‚Ä¢ [P] Toggle Remover (hide/restore)'
)
print('‚Ä¢ Bright Green Glow active  ‚Ä¢ Restorable Remover is AUTO-ACTIVE')
