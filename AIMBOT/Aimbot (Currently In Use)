--// ======================================================================
--//   PAYLOAD0 ‚Ä¢ AUTO-AIM + ALIGN-ASSIST SYSTEM [PURE BALL-ACTIVE VISUALS]
--//   ‚Ä¢ Auto-locks nearest visible rim
--//   ‚Ä¢ Smart aim shooting logic
--//   ‚Ä¢ Pushback assist active ONLY when player holds a ball
--//   ‚Ä¢ Bright green visuals show ONLY when ball is equipped
--//   ‚Ä¢ Calibration UI shows ONLY when holding a ball + key missing
--// ======================================================================

-- === SERVICES ===
local Players = game:GetService('Players')
local UserInputService = game:GetService('UserInputService')
local RunService = game:GetService('RunService')
local ReplicatedStorage = game:GetService('ReplicatedStorage')
local CoreGui = game:GetService('CoreGui')
local TweenService = game:GetService('TweenService')
local Workspace = game:GetService('Workspace')
local Camera = workspace.CurrentCamera

local plr = Players.LocalPlayer
local char = plr.Character or plr.CharacterAdded:Wait()
local remotes = ReplicatedStorage:WaitForChild('Remotes')
local shootRemote = remotes:WaitForChild('Shoot')

-- === STATE ===
getgenv().PAYLOAD0_SYSTEM_ACTIVE = true
local VisualsEnabled = true
local shootKey: string? = nil
local selectedRim: BasePart? = nil
local activeNotifyGui

-- === CONFIGURATION ===
local PERFECT_DISTANCES = { 54.97, 61.53, 68.10 }
local CLAMP_RADIUS = 1
local ACTIVE_RANGE_MAIN = 90
local MAX_PUSH = 0.06
local DAMPING = 0.9

local COLOR_GREEN = Color3.fromRGB(0, 255, 100)
local COLOR_GREEN_SOFT = Color3.fromRGB(0, 200, 80)

-- === HELPER: BALL CHECK ===
local function hasBall()
	local char = plr.Character
	if not char then
		return false
	end
	for _, tool in ipairs(char:GetChildren()) do
		if tool:IsA('Tool') and tool.Name:lower():find('ball') then
			return true
		end
	end
	return false
end

-- === NOTIFY SYSTEM ===
local function notify(msg, color)
	if activeNotifyGui and activeNotifyGui.Parent then
		activeNotifyGui:Destroy()
	end
	local gui = Instance.new('ScreenGui', CoreGui)
	gui.ResetOnSpawn = false
	activeNotifyGui = gui

	local label = Instance.new('TextLabel', gui)
	label.AnchorPoint = Vector2.new(0.5, 0.5)
	label.BackgroundTransparency = 1
	label.TextColor3 = color or Color3.fromRGB(255, 255, 255)
	label.Font = Enum.Font.Code
	label.TextSize = 26
	label.Text = msg
	label.Position = UDim2.new(0.5, 0, 0.9, 0)

	task.spawn(function()
		task.wait(1.2)
		if gui == activeNotifyGui then
			gui:Destroy()
			activeNotifyGui = nil
		end
	end)
end

-- === CALIBRATE UI (ONLY WHEN HOLDING BALL + NO KEY) ===
local calibrateGui
local function showCalibrateUI()
	if calibrateGui or shootKey or not hasBall() then
		return
	end

	calibrateGui = Instance.new('ScreenGui')
	calibrateGui.Name = 'CalibrateReminder'
	calibrateGui.ResetOnSpawn = false
	calibrateGui.IgnoreGuiInset = true
	calibrateGui.Parent = CoreGui

	local frame = Instance.new('Frame')
	frame.AnchorPoint = Vector2.new(0.5, 0.5)
	frame.Position = UDim2.new(0.5, 0, 0.85, 0)
	frame.Size = UDim2.new(0, 420, 0, 45)
	frame.BackgroundTransparency = 0.3
	frame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
	frame.BorderSizePixel = 0
	frame.Parent = calibrateGui

	local stroke = Instance.new('UIStroke')
	stroke.Color = Color3.fromRGB(80, 255, 120)
	stroke.Thickness = 1.6
	stroke.Parent = frame

	local corner = Instance.new('UICorner')
	corner.CornerRadius = UDim.new(0, 10)
	corner.Parent = frame

	local label = Instance.new('TextLabel')
	label.BackgroundTransparency = 1
	label.Size = UDim2.new(1, 0, 1, 0)
	label.Font = Enum.Font.GothamMedium
	label.TextSize = 22
	label.TextColor3 = Color3.fromRGB(120, 255, 150)
	label.Text = 'üèÄ Click once to calibrate your shot.'
	label.Parent = frame

	task.spawn(function()
		while calibrateGui and not shootKey and hasBall() do
			local t1 = TweenService:Create(
				label,
				TweenInfo.new(
					0.8,
					Enum.EasingStyle.Sine,
					Enum.EasingDirection.Out
				),
				{ TextTransparency = 0.3 }
			)
			local t2 = TweenService:Create(
				label,
				TweenInfo.new(
					0.8,
					Enum.EasingStyle.Sine,
					Enum.EasingDirection.Out
				),
				{ TextTransparency = 0 }
			)
			t1:Play()
			t1.Completed:Wait()
			t2:Play()
			t2.Completed:Wait()
		end
	end)
end

local function removeCalibrateUI()
	if calibrateGui then
		calibrateGui:Destroy()
		calibrateGui = nil
	end
end

task.spawn(function()
	while task.wait(0.5) do
		if not hasBall() or shootKey then
			removeCalibrateUI()
		else
			showCalibrateUI()
		end
	end
end)

-- === RIM TRACKING ===
local RimSize =
	Vector3.new(3.632131576538086, 0.5587897300720215, 3.632131576538086)
local Rims = {}
Workspace.DescendantAdded:Connect(function(o)
	if o:IsA('BasePart') and o.Name == 'Rim' and o.Size == RimSize then
		table.insert(Rims, o)
	end
end)
for _, v in ipairs(Workspace:GetDescendants()) do
	if v:IsA('BasePart') and v.Name == 'Rim' and v.Size == RimSize then
		table.insert(Rims, v)
	end
end
Workspace.DescendantRemoving:Connect(function(o)
	for i, rim in ipairs(Rims) do
		if rim == o then
			table.remove(Rims, i)
			break
		end
	end
	if selectedRim == o then
		selectedRim = nil
	end
end)

-- === AUTO RIM LOCK ===
task.spawn(function()
	while task.wait(0.1) do
		if not getgenv().PAYLOAD0_SYSTEM_ACTIVE then
			continue
		end
		local root = plr.Character
			and plr.Character:FindFirstChild('HumanoidRootPart')
		if not root then
			continue
		end
		local bestRim, bestDist = nil, 85
		for _, rim in ipairs(Rims) do
			if rim:IsDescendantOf(Workspace) then
				local dist = (rim.Position - root.Position).Magnitude
				if dist < bestDist then
					local _, on = Camera:WorldToViewportPoint(rim.Position)
					if on then
						bestRim, bestDist = rim, dist
					end
				end
			end
		end
		if bestRim and bestRim ~= selectedRim then
			selectedRim = bestRim
		end
	end
end)

-- === TOGGLES ===
UserInputService.InputBegan:Connect(function(i, gp)
	if gp then
		return
	end

	if i.KeyCode == Enum.KeyCode.O then
		VisualsEnabled = not VisualsEnabled
		notify(
			VisualsEnabled and 'üëÅ Visuals ON' or 'üôà Visuals OFF',
			VisualsEnabled and COLOR_GREEN or Color3.fromRGB(255, 80, 80)
		)
	end

	if i.KeyCode == Enum.KeyCode.V then
		getgenv().PAYLOAD0_SYSTEM_ACTIVE = not getgenv().PAYLOAD0_SYSTEM_ACTIVE
		notify(
			getgenv().PAYLOAD0_SYSTEM_ACTIVE and '‚úÖ System ON'
				or 'üö´ System OFF',
			getgenv().PAYLOAD0_SYSTEM_ACTIVE and COLOR_GREEN
				or Color3.fromRGB(255, 80, 80)
		)
	end
end)

-- === SHOOT KEY CAPTURE (LISTEN ONLY) ===
local old
old = hookmetamethod(game, '__namecall', function(self, ...)
	local m = getnamecallmethod()
	if m == 'FireServer' and self == shootRemote then
		local args = { ... }
		if type(args[3]) == 'string' and not shootKey then
			shootKey = args[3]
			removeCalibrateUI()
			notify('Shoot key captured!', COLOR_GREEN)
		end
	end
	return old(self, ...)
end)

-- === SHOOT LOGIC ===
local lastTick, moveOffset = 0, Vector3.zero
local function computeOffset()
	if tick() - lastTick > 0.1 then
		local hum = plr.Character
			and plr.Character:FindFirstChildOfClass('Humanoid')
		local moveDir = (hum and hum.MoveDirection) or Vector3.zero
		moveOffset = Vector3.new(moveDir.X * 1.5, 0, moveDir.Z * 1.5)
		lastTick = tick()
	end
	return moveOffset
end

local function computeArc(dist)
	return Vector3.new(0, 43 + (dist / 15), 0)
end

local function smartAim(rim)
	local offset = computeOffset()
	local root = plr.Character
		and plr.Character:FindFirstChild('HumanoidRootPart')
	if not root then
		return rim.Position
	end
	local dist = (root.Position - rim.Position).Magnitude
	return rim.Position + computeArc(dist) - offset
end

local function shootAtTarget()
	if not getgenv().PAYLOAD0_SYSTEM_ACTIVE then
		return
	end
	if not (selectedRim and selectedRim:IsDescendantOf(Workspace)) then
		return
	end
	if not shootKey then
	end

	local char = plr.Character
	if not char then
		return
	end
	local head, root = char:FindFirstChild('Head'), char.PrimaryPart
	if not (head and root) then
		return
	end

	local aimPos = smartAim(selectedRim)
	local dir = (aimPos - head.Position).Unit
	local shootFrom = root.Position + dir * 3.8
	if shootFrom.Y - root.Position.Y < 4 then
		shootFrom = root.Position + dir * 4
	end
	shootRemote:FireServer(aimPos, shootFrom, shootKey)
end

UserInputService.InputBegan:Connect(function(i, gp)
	if gp or not getgenv().PAYLOAD0_SYSTEM_ACTIVE then
		return
	end
	if i.UserInputType == Enum.UserInputType.MouseButton1 and hasBall() then
		shootAtTarget()
	end
end)

-- === HIGHLIGHT VISUAL ===
local hl = CoreGui:FindFirstChild('PerfectRangeGlow')
	or Instance.new('Highlight')
hl.Name = 'PerfectRangeGlow'
hl.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
hl.FillTransparency = 0.25
hl.OutlineTransparency = 0
hl.Adornee = plr.Character
hl.Parent = CoreGui
hl.Enabled = false

local moveKeys = { W = false, A = false, S = false, D = false }
UserInputService.InputBegan:Connect(function(i, gp)
	if gp then
		return
	end
	if moveKeys[i.KeyCode.Name] ~= nil then
		moveKeys[i.KeyCode.Name] = true
	end
end)
UserInputService.InputEnded:Connect(function(i, gp)
	if gp then
		return
	end
	if moveKeys[i.KeyCode.Name] ~= nil then
		moveKeys[i.KeyCode.Name] = false
	end
end)

local function shouldPush()
	local count = 0
	for _, v in pairs(moveKeys) do
		if v then
			count += 1
		end
	end
	return count == 1 and (moveKeys.A or moveKeys.D)
end

-- === PUSH LOGIC ===
local rimsForPush = {}
for _, v in ipairs(Workspace:GetDescendants()) do
	if
		v:IsA('BasePart')
		and v.Name == 'Lol'
		and v.Parent
		and v.Parent.Name == 'Rim'
	then
		table.insert(rimsForPush, v)
	end
end

local function nearestRim(rootPos)
	local nearest, nearestDist
	for _, rim in ipairs(rimsForPush) do
		if rim:IsDescendantOf(Workspace) then
			local rimXZ = Vector3.new(rim.Position.X, 0, rim.Position.Z)
			local dist = (rimXZ - Vector3.new(rootPos.X, 0, rootPos.Z)).Magnitude
			if not nearestDist or dist < nearestDist then
				nearest, nearestDist = rim, dist
			end
		end
	end
	return nearest, nearestDist
end

local function getNearestPerfectDistance(current)
	local nearest, smallestDiff
	for _, pd in ipairs(PERFECT_DISTANCES) do
		local diff = math.abs(pd - current)
		if not smallestDiff or diff < smallestDiff then
			nearest, smallestDiff = pd, diff
		end
	end
	return nearest
end

-- === RUNTIME LOOP ===
local smoothBias = Vector3.zero
RunService.RenderStepped:Connect(function()
	if not getgenv().PAYLOAD0_SYSTEM_ACTIVE then
		hl.Enabled = false
		return
	end

	local char = plr.Character
	local hum = char and char:FindFirstChildOfClass('Humanoid')
	local root = char and char:FindFirstChild('HumanoidRootPart')
	if not (hum and root) then
		return
	end

	if not hasBall() then
		hl.Enabled = false
		return
	end

	local rim, dist = nearestRim(root.Position)
	if not rim or dist > ACTIVE_RANGE_MAIN then
		hl.Enabled = false
		smoothBias = Vector3.zero
		return
	end

	local target = getNearestPerfectDistance(dist)
	local diff = dist - target
	local absDiff = math.abs(diff)
	local desired = Vector3.zero

	if shouldPush() and absDiff < CLAMP_RADIUS then
		local strength = (CLAMP_RADIUS - absDiff) / CLAMP_RADIUS
		local toRim = Vector3.new(rim.Position.X, 0, rim.Position.Z)
			- Vector3.new(root.Position.X, 0, root.Position.Z)
		local distSign = math.sign(diff)
		if distSign > 0 then
			local pushDir = -toRim.Unit
			desired = pushDir * math.min(strength * MAX_PUSH, MAX_PUSH)
		end
	end

	smoothBias = smoothBias * DAMPING + desired * (1 - DAMPING)
	root.CFrame += Vector3.new(smoothBias.X, 0, smoothBias.Z)

	if VisualsEnabled then
		hl.Enabled = true
		if absDiff <= 0.10 then
			hl.FillColor, hl.OutlineColor = COLOR_GREEN, COLOR_GREEN
		elseif absDiff < CLAMP_RADIUS then
			hl.FillColor, hl.OutlineColor = COLOR_GREEN_SOFT, COLOR_GREEN_SOFT
		else
			hl.Enabled = false
		end
	else
		hl.Enabled = false
	end
end)

plr.CharacterAdded:Connect(function(c)
	task.wait(0.5)
	hl.Adornee = c
end)
